#include <iostream>
#include <string>
#include<cstdlib>
#include<ctime>

//본 프로그램은 카드게임 SET을 콘솔 프로그램으로 제작한 것입니다. 규칙은 해당 사이트를 참조하시기 바랍니다.
//http://danbis.net/13166

using namespace std;

const string colorst[3] = { "Green", "Red", "Purple" };
const string shapest[3] = { "Oval", "Rectangle", "Distorted" };
const string brightnessst[3] = { "Full", "Half", "Empty" };//전역 범위로 정의 수정 필요

class Card;

bool cardset(Card c1, Card c2, Card c3);

class Card{
	int color, num, shape, brightness,cardnum;

public:
	Card()//배열로 선언을 위한 기본형
	{
		color = 0;
		num = 0;
		shape = 0;
		brightness = 0;
	}
	Card(int n)//0<=n<=80(3진법 취급함) 카드 넘버를 입력받아서 지정할 때
	{
		color = n / (3 * 3 * 3);
		num = (n - color * 27) / 9;
		shape = (n - color * 27 - num * 9) / 3;
		brightness = n - color * 27 - num * 9 - shape * 3;
	}
	Card(int color, int num, int shape, int brightness)//카드 요소를 입력받아서 지정할 때
	{
		this->color = color;
		this->num = num;
		this->shape = shape;
		this->brightness = brightness;
	}
	void printcard()//카드 요소를 정리하여 출력
	{
		cout << "Color : " << colorst[color] << endl;
		cout << "Number : " << num + 1 << endl;
		cout << "Shape : " << shapest[shape] << endl;
		cout << "Brightness : " << brightnessst[brightness] << endl;
	}
	void cardsetnum(int n)
	{
		color = n / (3 * 3 * 3);
		num = (n - color * 27) / 9;
		shape = (n - color * 27 - num * 9) / 3;
		brightness = n - color * 27 - num * 9 - shape * 3;
		cardnum = n;
	}
	void setcolor(int n)
	{
		this->color = n;
	}
	void setnum(int n)
	{
		this->num = n;
	}
	void setshape(int n)
	{
		this->shape = n;
	}
	void setbright(int n)
	{
		this->brightness = n;
	}
	void setall(int color, int num, int shape, int brightness)
	{
		this->color = color;
		this->num = num;
		this->shape = shape;
		this->brightness = brightness;
	}
	inline int getcolor()
	{
		return color;
	}
	inline int getnum()
	{
		return num;
	}
	inline int getshape()
	{
		return shape;
	}
	inline int getbright()
	{
		return brightness;
	}
	inline int getcardnum()
	{
		return cardnum;
	}
};

class Gamesy{
private:
	bool dec[81];//81장의 카드 덱의 사용 여부를 저장하는 배열
	int score;//점수를 저장
	Card currentdec[15];//현재의 카드 덱 저장(12장 기본에 간헐적으로 3장이 추가 되므로 15장으로 일단 정의한다. )
	int answer[3];
	int decsize = 81;
public:
	bool numar(int n, int k = 3);
	Gamesy()
	{
		for (int i = 0; i < 81; i++)//모든 카드를 사용되지 않음 상태로 초기화
			dec[i] = 1;
		srand((unsigned)time(0));
		for (int i = 0; i < 12; i++)//초기 카드 덱 설정
		{
			cout << i+1 <<" 번째 카드"<< endl;
			currentdec[i].cardsetnum(drawnewchange());
			//currentdec[i].printcard();
		}
		cout << "SET 게임을 시작합니다." << endl;
		do{
			int answerex = numar(12);
			if (answerex == 0)
			{
				if (decsize == 0)
					break;
				dec12to15();
				carddecprint(15);
				numar(15);//테스트(답확인용)
			}
			else
			{
				carddecprint(12);
				numar(12);//테스트(답획인용)
			}
			cout << "남은 카드 : "<<decsize << " 장"<< endl;
			getanswer(answerex);
			answerjudge(answerex);
		} while (decsize >= 0);//남은 카드가 12장 미만이면 게임 종료

	}
	int drawnewchange()
	{
		int n;
		do{
			n = rand() % 81;
		} while (dec[n] == 0);
		drawcard(n);
		decsize--;
		return n;
	}
	void drawcard(int n)//사용되지 않은 카드를 사용됨 상태로 바꾼다. 
	{
		if (dec[n] == 0)
			cout << n + 1 << " : used card" << endl;
		else
			dec[n] = 0;
	}
	void returncard(int n)//사용된 카드를 사용되지 않음 상태로 바꾼다. 
	{
		if (dec[n] == 1)
			cout << n + 1 << " : unused card" << endl;
		else
			dec[n] = 1;
	}
	void getanswer(int n)//조건에 맞는 답 입력받음.
	{
		cout << "SET을 만족하는 세 카드의 숫자를 입력하세요 : " << endl;
			do{
				cin >> answer[0] >> answer[1] >> answer[2];;
			} while (answer[1] == 0 || answer[2] == 0 || answer[0] == answer[1] || answer[0] == answer[2] || answer[1] == answer[2] || answer[0] > 12 + 3*(1-n) || answer[1] > 12+3*(1-n) || answer[2] > 12+3*(1-n));
	}//입력한 숫자중 일치하는 숫자가 있거나, 12 혹은 15 이상이거나(덱 크기에 따라 달라짐), 0이 있을 시 재입력
	bool answerjudge(int n)//답이면 1 반환 후 답인 카드를 새로운 카드를 뽑아 바꿈, 아니면 0 반환
	{
		if (cardset(currentdec[answer[0]-1], currentdec[answer[1]-1], currentdec[answer[2]-1]))
		{
			cout << "정답입니다" << endl;
			if (n)//카드를 12개 뽑은 상태에선 새로운 카드 뽑는다
			{
				for (int i = 0; i < 3; i++)
				{
					currentdec[answer[i] - 1].cardsetnum(drawnewchange());//답이였던 카드를 재설정함
				}
			}
			else//카드를 15개 뽑은 상태에선 카드 정렬만 한다. 
				dec15to12();
			return 1;
		}
		else
		{
			cout << "답이 틀렸습니다."<<endl;
			return 0;
		}
	}
	void dec12to15()//답이 없을 때 카드 3장 추가
	{
		for (int i = 0; i < 3; i++)
		{
			currentdec[12+i].cardsetnum(drawnewchange());//카드 13,14,15번 할당
		}
	}
	void dec15to12()//15장이 뽑힌 상태에서 답을 맞춰서 카드 3장이 빠질 경우 카드 정렬
	{
		bool dectemp[15];
		for (int i = 0; i < 15; i++)
			dectemp[i] = 1;
		for (int i = 0; i < 3; i++)
			dectemp[answer[i] - 1] = 0;
		for (int i = 0; i < 14; i++)
		{
			for (int j = i; j < 14; j++)
			{
				if (dectemp[j] < dectemp[j + 1])
				{
					bool temp;
					temp = dectemp[j];
					dectemp[j] = dectemp[j + 1];
					dectemp[j + 1] = temp;

					Card tempc;
					tempc = currentdec[j];
					currentdec[j] = currentdec[j + 1];
					currentdec[j + 1] = tempc;//버블정렬을 이용해서 사용된 카드를 13~15번으로 민다. 
				}
			}
		}
	}
	void carddecprint(int n)
	{
		for (int i = 0; i < n; i++)
		{
			cout << i + 1 << "번째 카드" << endl;
			currentdec[i].printcard();
		}
	}
};

bool cardset(Card c1, Card c2, Card c3)//3장의 카드가 set조건을 만족하면 1 반환, 아니면 0 반환
{
	bool out = (((c1.getcolor() + c2.getcolor() + c3.getcolor()) % 3) == 0) &&
		(((c1.getnum() + c2.getnum() + c3.getnum()) % 3) == 0) &&
		(((c1.getshape() + c2.getshape() + c3.getshape()) % 3) == 0) &&
		(((c1.getbright() + c2.getbright() + c3.getbright()) % 3) == 0);//모든 요소 각각의 합이 3의 배수인 경우 set임. set인 경우 out에 1 저장
	return out;
}

bool Gamesy::numar(int n, int k)//답이 없으면 0 반환, 있으면 1 반환
{
	int i, j, r, count, re, kcou, ncou;
	bool answerexist = 0;
	int karr[4];
	count = 0;
	for (i = 0; i < k; i++)//콤비네이션 출력용 배열에 1, 2 ~ k 저장
	{
		r = i + 1;
		karr[i] = r;
	}

	re = 1;
	while (re)
	{
		int knum;
		knum = karr[k - 1];
		for (i = 0; i < n - knum + 1; i++)//콤비네이션 의 마지막 숫자를 1씩 증가시키면서 출력
		{
			r = i + knum;
			karr[k - 1] = r;
			if (cardset(currentdec[karr[0]-1], currentdec[karr[1]-1], currentdec[karr[2]-1]))
			{
				answerexist = 1;
				cout << karr[0] << "번 " << karr[1] << "번 " << karr[2] << "번 SET" << endl;//테스트용
			}
			/*for (j = 0; j < k; j++)
				printf("%d,", karr[j]);
			printf("\n");*/
			count++;
		}
		kcou = k - 1;//k-a 번째 콤비네이션 숫자와 n-a 가 다를 경우 k-a번째 콤비넨이션 숫자를 1 증가시키고, k-a+1, k-a+2...k번째 콤비네이션 숫자를 1씩 증가시켜 할당.
		ncou = n;
		while (karr[kcou] == ncou)
		{
			kcou--;
			ncou--;
		}
		if (kcou < 0)//1번째 콤비네이션의 숫자가 최대가 되면 반복 종료, 아니면 반복
			re = 0;
		else
		{
			karr[kcou]++;
			for (kcou; kcou < k; kcou++)
			{
				karr[kcou + 1] = karr[kcou] + 1;
			}
			re = 1;
		}
	}
	i = 0, j = 0, r = 0;//초기화
	return answerexist;
}

int main()
{
	Gamesy G;
}
